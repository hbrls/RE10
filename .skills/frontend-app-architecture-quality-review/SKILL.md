---
name: frontend-app-architecture-quality-review
description: This skill should be used when performing comprehensive architecture quality reviews for front-end applications. It provides systematic workflows for analyzing build & dependency management, base framework, utilities, business modules, and third-party integrations. The actual tech stack should be derived from the current project.
---

> updated_by: Cascade - GPT-5
> updated_at: 2026-02-13 17:22:00

# 前端应用架构质量审查计划（Skill）

## 技能概述

本技能指导 AI 助手对“前端应用”进行系统性的架构质量审查。审查应以当前项目事实为准（代码、依赖、构建配置、运行形态），并将结论输出到仓库的 `.plans/` 目录中。

## 使用时机

**重要说明：** 本技能专门用于项目级架构质量审查，关注整体架构设计、模块划分、依赖关系等架构层面的问题。

在以下情况下应该使用此技能：

**核心使用场景 - 架构审查：**

-   需要对整个前端应用进行架构质量审查
-   评估项目架构设计的合理性和可维护性
-   识别架构层面的设计问题和改进机会
-   评估技术选型和架构决策的合理性
-   项目重构前的架构评估

## 审查维度（通用）

本技能从前端应用的五个核心构成部分出发，对架构质量进行系统审查：Build（构建与依赖管理）、基础框架（Base Framework）、Utils（工具层）、业务组件/模块、第三方库（集成与隔离）。

### Phase 1 Build（构建与依赖管理）

#### 1.1 审查目标

-   确保 Webpack 构建配置结构清晰、职责单一、便于维护和扩展。
-   控制依赖版本与冲突，避免不必要的冗余依赖和隐性升级风险。
-   清晰区分不同环境（开发 / 测试 / 生产）的构建配置，降低配置错误风险。
-   优化构建性能，缩短构建时间，提升开发与 CI 效率。

#### 1.2 核心关注点

-   **模块与依赖关系**：

    -   项目模块划分是否合理（src/、view/、components/、api/、libs/、directive/等）
    -   是否存在循环依赖或不合理的依赖关系
    -   基础模块是否被高层模块错误依赖

-   **构建配置规范性**：

    -   `vue.config.js` / `webpack.config.js` 配置是否清晰合理
    -   是否使用统一的版本管理（package.json）
    -   是否有清晰的注释说明关键配置
    -   环境变量配置是否规范（.env.\* 文件）
    -   是否存在构建阶段副作用（例如构建/启动时写入运行时配置文件），是否会导致本地与 CI 环境不一致
    -   是否正确配置本地开发代理（如 devServer proxy），避免跨域与环境切换问题被业务代码“硬编码”掩盖

-   **版本与仓库管理**：

    -   依赖版本是否固定且可追踪（package.json、yarn.lock/pnpm-lock.yaml）
    -   是否避免使用不可信仓库
    -   是否定期评估和升级关键依赖
    -   是否使用 webpack 的 DefinePlugin 或 .env 文件

-   **构建类型与环境**：

    -   是否正确配置开发、测试、生产环境
    -   环境变量是否通过安全方式注入
    -   是否正确使用 `VUE_APP_` 前缀的环境变量（Vue CLI）
    -   环境信息是否存在“双源/多源”导致的环境漂移风险（例如请求 baseURL 与路由 dev 判断来自不同环境源）
    -   开发态/生产态功能开关是否完全由环境源控制，避免出现“生产误暴露 Demo/脚手架页面”的风险

-   **安全与合规**：

    -   构建配置中是否存在明文秘钥、账号密码或敏感 URL
    -   是否对调试开关、日志开关等做了环境隔离
    -   生产环境是否正确配置（代码压缩、混淆等）
    -   是否存在 `eval`、动态执行配置等不利于审计与静态分析的做法

-   **关联审查产物（Build）**：
    -   `/.plans/架构质量审查-001-Build.md`

### Phase 2 基础框架（Base Framework）

#### 2.1 审查目标

-   确保应用整体架构模式（如 MVC/MVVM/组件化架构）在各模块中得到一致、正确的实现。
-   建立清晰的分层与边界（视图层 / 业务逻辑层 / 数据层），避免横向耦合和"上帝组件"。
-   通过统一的基础组件（如布局组件、路由配置、状态管理、API 封装）提升复用性与可维护性。
-   提供稳定的错误处理、日志与配置体系，为排查问题和运维提供支撑。

#### 2.2 核心关注点

-   **UI 框架与设计系统**：

    -   项目主体使用的 UI 框架/组件库是什么（自研/开源/商业），是否存在多 UI 框架混用
    -   是否存在二次封装层（Design System / UI Adapter），以及与业务组件的依赖方向是否清晰
    -   样式体系是否统一（主题、暗色模式、CSS 方案、全局变量、覆盖策略），是否存在样式污染与冲突

-   **登录与账号体系**：

    -   登录入口与鉴权链路是否清晰（登录态获取、续期/刷新、登出、失效处理）
    -   Token/Session 的存储策略是否安全（Cookie/LocalStorage/Memory），是否有统一的请求拦截与错误处理
    -   用户信息与权限模型的来源与缓存策略是否明确（角色/权限点/路由权限），是否有一致的访问控制边界
    -   权限数据缺失/获取失败时的默认策略是否安全（默认拒绝 vs 默认放行）
    -   不同环境下鉴权策略是否一致（例如 token 注入、header 策略、cookie 策略）

-   **架构模式一致性**：

    -   是否在全局范围内明确并坚持某一种架构模式
    -   是否存在同一模块内混用多种模式的情况
    -   是否正确使用当前项目的主框架范式（如 React Hooks/Vue Options API/Vue Composition API 等）

-   **分层与依赖方向**：

    -   上层是否只依赖下层抽象接口而非具体实现
    -   是否存在视图层直接操作数据源或 API 层的情况
    -   是否正确使用当前项目的状态管理方案（如 Vuex/Pinia/Redux/Zustand 等）
    -   是否正确使用当前项目的路由方案（如 Vue Router/React Router 等）
    -   动态路由/菜单是否具备可信来源校验（白名单/签名/后端校验），避免本地存储被篡改造成路由注入

-   **基础组件设计**：

    -   布局组件（Layout、Header、Sidebar、Footer）是否只承担通用职责
    -   是否被滥用为"万能基类"，导致子组件难以扩展或重用
    -   是否正确使用当前项目框架提供的跨层通信/依赖注入机制（如 provide/inject、context 等）

-   **网络与数据访问框架**：

    -   是否存在统一的 API 封装（如 axios 拦截器）
    -   错误与异常是否集中处理
    -   重试与超时策略是否可配置
    -   是否正确处理 Token 和鉴权信息

-   **检查更新与版本治理**：

    -   更新策略是否明确：可选更新 vs 强制更新，是否支持灰度/分渠道/分地区/分设备策略
    -   阻断时机是否合理：强制更新是否在进入关键业务流程前拦截（而非进入主页面后才提示）
    -   频控与用户体验：关闭/稍后再提醒的口径是否清晰、实现是否正确（时间差计算、跨版本策略）
    -   下载与安装链路是否可控：商店更新 vs 直链下载，是否具备失败重试、断点续传、仅 Wi-Fi 等策略
    -   安全与合规：下载 URL 白名单/HTTPS、APK 完整性校验（hash/signature）、未知来源安装授权引导
    -   可观测性闭环：曝光/点击/下载成功率/安装成功率/失败原因是否可追踪与告警

-   **日志与错误收集**：

    -   是否有统一的日志工具与错误收集框架
    -   日志级别与输出在不同构建环境中是否区分管理
    -   日志输出是否避免打印敏感信息
    -   是否支持按模块或功能维度配置日志开关
    -   是否具备可观测性闭环（路由、请求、关键用户动作能够被关联追踪）

-   **关联审查产物（基础框架）**：

    -   `/.plans/架构质量审查-002-基础框架.md`
    -   `/.plans/架构质量审查-002-基础框架-UI.md`
    -   `/.plans/架构质量审查-002-基础框架-登录.md`
    -   `/.plans/架构质量审查-002-基础框架-检查更新.md`

-   **配置与开关**：
    -   是否存在统一的配置中心（如常量、开关、实验配置）
    -   避免散落的硬编码和魔法值
    -   是否正确使用环境变量管理配置

### Phase 3 Utils（工具层）

#### 3.1 审查目标

-   将通用能力从业务中抽离为工具层，提升代码复用率，减少重复实现。
-   控制工具类的职责范围，避免形成难以测试和理解的"工具黑洞"。
-   确保工具层对框架运行时（响应式、生命周期、全局单例等）的依赖是清晰、可控且不会引入内存泄漏。

#### 3.2 核心关注点

-   **职责单一性**：

    -   单个工具类/方法是否聚焦单一领域（如日期、字符串、文件、网络）
    -   是否存在"大杂烩式"工具类
    -   Mixins 是否职责单一、可复用
    -   是否存在“工具层夹带业务规则/数据结构”的情况，导致工具层难以复用与迁移

-   **命名与组织**：

    -   文件结构与命名是否清晰反映用途
    -   是否存在大量"CommonUtils"、"Utils2"等模糊命名
    -   Mixins 命名是否清晰描述功能域
    -   工具函数是否存在重复实现（格式化/解析/下载/加密/日志等能力散落在页面/组件）

-   **静态方法与全局状态**：

    -   是否过度使用全局状态，导致难以管理
    -   是否正确使用当前项目的状态管理方案管理全局状态
    -   是否避免在工具函数中直接操作 DOM

-   **响应式使用**：

    -   工具函数获取 Vue 实例数据的方式是否安全
    -   是否避免长期持有组件引用
    -   是否正确处理 this 绑定问题

-   **本地存储与缓存（Storage）**：

    -   存储分层是否清晰：KV（配置/状态）vs 文件缓存（可过期）vs DB（结构化/查询）
    -   是否避免在工具层散落多套存储实现（多套 SP/MMKV/DB/文件缓存并存）且缺少治理规范
    -   Key/Schema 是否集中治理：命名规范、命名空间/模块隔离、迁移策略（升级/灰度/回滚）
    -   数据生命周期是否可控：登录/登出、切换账号、撤回同意、风控触发等场景下的清理策略是否明确
    -   安全与合规：敏感数据是否最小化落盘；必须落盘时是否加密；备份/导出/Root 风险是否评估
    -   性能与可靠性：主线程写入控制（commit/apply）、高频写入合并、容量上限/淘汰策略、读写失败兜底
    -   可观测性：命中率、占用、清理耗时、写入失败率等指标是否可监控

-   **设备信息（Device Info）**：

    -   设备信息采集是否最小化（仅采集业务必需字段），避免过度采集硬件标识与可识别信息
    -   字段来源与口径是否统一（系统 API、SDK 回传、自定义拼装），避免同一指标多源漂移
    -   设备指纹相关逻辑是否具备合规约束（告知/同意/撤回后降级），并避免将敏感标识明文落盘
    -   采集失败、权限受限、系统版本差异场景是否有兜底与降级策略
    -   是否建立可观测性（采集成功率、字段缺失率、上报延迟、异常告警）

-   **日期时间与时区（DateTime / Timezone）**：

    -   日期解析与格式化是否统一入口（避免各处硬编码 `yyyy-MM-dd HH:mm:ss`、`dd/MM/yyyy`、ISO 模板）
    -   时区与 Locale 策略是否清晰（展示使用本地时区、服务端交互使用约定时区），并避免隐式依赖系统默认值
    -   时间戳单位是否显式治理（`timestampMs` / `timestampSec`），避免秒/毫秒混用导致比较与排序错误
    -   是否覆盖夏令时、跨时区、跨日边界（00:00 附近）等关键边界场景，避免日期偏移与展示错误
    -   国家/地区日期展示规则是否配置化，避免按国家码散落条件分支造成维护成本上升

-   **可测试性**：

    -   工具方法是否易于通过单元测试验证
    -   是否与 UI 或外部环境强耦合导致无法隔离测试
    -   Mixins 是否易于测试
    -   关键工具函数是否覆盖边界条件（空值/异常输入/编码/时区等）并具备回归保障

-   **关联审查产物（Utils）**：
    -   `/.plans/架构质量审查-003-Utils.md`
    -   `/.plans/架构质量审查-003-Utils-Http.md`
    -   `/.plans/架构质量审查-003-Utils-Log.md`
    -   `/.plans/架构质量审查-003-Utils-Storage.md`
    -   `/.plans/架构质量审查-003-Utils-加解密.md`
    -   `/.plans/架构质量审查-003-Utils-WebSocket.md`
    -   `/.plans/架构质量审查-003-Utils-DateTime.md`
    -   `/.plans/架构质量审查-003-Utils-Currency.md`
    -   `/.plans/架构质量审查-003-Utils-Icon.md`
    -   `/.plans/架构质量审查-003-Utils-设备信息.md`
    -   `/.plans/架构质量审查-003-Utils-报表.md`

### Phase 4 业务组件（业务功能层）

#### 4.1 审查目标

-   确保 Vue 组件结构清晰、职责明确，避免臃肿和过多业务逻辑堆积。
-   实现视图与业务逻辑的合理分离（如通过 hooks/mixins、store、service 等），提升可维护性与扩展性。
-   在业务复杂场景下保证组件状态管理、路由导航与数据交互的可控与可测试。

#### 4.2 核心关注点

-   **组件复杂度**：

    -   单个组件（.vue 文件）行数、方法数是否过多
    -   是否存在组件规模长期失控的情况（例如约定阈值：单文件超过一定行数需要拆分）
    -   是否集中处理了过多流程逻辑
    -   可否拆分为子组件或下沉到 Mixins
    -   Props / Events 定义是否完整清晰（类型、默认值、事件协议、是否存在隐式依赖）

-   **状态管理**：

    -   组件状态（加载中/成功/失败/空数据等）是否有统一的表示与切换方式
    -   是否存在大量 if-else 分支控制 UI 状态
    -   是否正确使用当前项目的状态管理方案管理全局状态
    -   是否正确使用 data() 定义组件状态

-   **视图与业务逻辑分离**：

    -   UI 层是否只负责视图展示与用户交互
    -   业务逻辑是否下沉到 Mixins/Store/Services 等
    -   组件内逻辑是否按职责拆分（事件处理、状态更新、数据转换、API 调用等）

-   **路由与导航**：

    -   页面跳转是否集中管理或通过路由框架
    -   是否存在大量硬编码的路由路径字符串
    -   是否正确使用当前项目路由方案的导航守卫/拦截器机制（若存在）
    -   业务旅程是否可追溯（核心链路、列表-详情-审批流的路由地图是否可维护/可视化）
    -   动态路由（菜单下发/本地缓存拼装）是否具备统计与治理手段（路由注册日志/审计输出）

-   **列表与复杂 UI**：

    -   表格、树形等复杂组件的设计是否清晰
    -   是否正确使用当前项目的 UI 组件库/设计系统（若存在）
    -   是否存在严重的布局嵌套或性能问题
    -   大数据量表格是否使用虚拟滚动
    -   列表页到详情页的跳转/缓存策略是否一致（hideInMenu/notCache 等约定是否统一）

-   **异常与边界处理**：

    -   网络失败、权限拒绝、空数据、超时等场景是否有明确的用户反馈与回退策略
    -   是否正确处理错误边界
    -   是否提供友好的错误提示
    -   定时器和事件监听器是否在 beforeDestroy 中清理
    -   核心页面是否存在硬编码禁用/死代码，导致“页面看似存在但实际不可用”的风险

-   **关联审查产物（业务页面与旅程）**：
    -   `/.plans/架构质量审查-004-业务页面.md`
    -   `/.plans/架构质量审查-004-业务页面-首页.md`
    -   `/.plans/架构质量审查-004-业务页面-主旅程.md`
    -   `/.plans/架构质量审查-004-业务页面-营销位.md`

### Phase 5 第三方库（集成与隔离）

#### 5.1 审查目标

-   通过适配层或封装层对第三方库进行隔离，降低对业务代码的侵入与耦合。
-   确保第三方库的使用安全、合规，可控地采集数据并满足隐私与合规要求。
-   便于后续替换或升级第三方库，降低供应商锁定风险。

#### 5.2 核心关注点

-   **封装与抽象**：

    -   是否为各类库（图表/地图/支付/认证等）提供统一封装与适配层，避免业务直调第三方 API
    -   依赖方向是否清晰：业务依赖自有抽象；SDK 细节被隔离并可替换

-   **初始化与生命周期**：

    -   初始化是否集中管理（入口、依赖顺序、线程模型），是否避免阻塞冷启动/首屏
    -   生命周期是否正确：前后台切换、页面销毁、资源释放、重复初始化

-   **错误与降级**：

    -   SDK 不可用/调用失败/配置失效时是否有兜底与降级，且不阻断关键流程
    -   用户可感知的失败是否有可理解的提示与可恢复路径

-   **版本管理**：

    -   版本是否可追踪、可复现（锁定/变更记录），是否关注弃用与安全公告
    -   是否具备升级策略与回滚预案（灰度、开关、兼容层）
    -   是否存在“引入但未使用/痕迹弱”的重型依赖（可裁剪）

-   **权限与隐私**：

    -   权限申请是否最小化且可解释；拒绝授权是否可降级
    -   采集与上报是否与隐私政策一致；是否支持撤回同意后的停采/降级
    -   供应链风险：外部资源、Key/证书/签名、白名单与环境隔离是否规范

-   **埋点/分析 SDK（行为分析、日志事件、崩溃与可观测性）**：

    -   技术栈边界是否清晰：平台分析 vs 自建数据平台 vs 第三方 SDK，是否避免重复采集
    -   事件/用户体系是否统一：命名、参数字典、用户 ID/属性、跨端口径
    -   数据质量是否可监控：丢失/延迟/重复、采样、动态开关、异常告警
    -   可观测性是否闭环：关键事件能否关联页面/请求/崩溃/核心业务动作
    -   性能与合规：初始化与上报是否异步可控，是否避免采集敏感信息

-   **归因/结算 SDK（投放效果归因与转化回传）**：

    -   技术栈边界是否清晰：平台原生（Google/Meta/穿山甲）vs MMP（如 AppsFlyer/Adjust）vs 服务端回传
    -   转化回传是否可审计：触发时机、参数、失败重试、幂等/去重、异常告警
    -   口径是否统一：激活/注册/下单/放款等定义一致，避免多 SDK 口径漂移
    -   策略是否配置化：归因窗口/优先级/再归因策略，避免硬编码散落
    -   对账与合规：端/服/平台报表是否可对账，“结算口径以谁为准”是否明确；最小化采集与撤回同意降级

-   **地图/定位 SDK（地理能力、POI、路线与地址解析）**：

    -   能力是否通过适配层提供：地图/定位/地理编码/POI/路线等避免业务直耦合
    -   权限与合规：权限分级、拒绝授权降级、采集频率/精度控制、避免未授权采集
    -   稳定性：服务不可达、Key 失效、SDK 异常时兜底不阻断主流程
    -   风控与成本：Key/签名/白名单、配额、异常调用监控、环境隔离
    -   性能：按需初始化，避免主线程阻塞与冷启动/首屏抖动

-   **关联审查产物（第三方库/SDK）**：

    -   `/.plans/架构质量审查-005-SDK.md`
    -   `/.plans/架构质量审查-005-SDK-埋点.md`
    -   `/.plans/架构质量审查-005-SDK-广告归因.md`
    -   `/.plans/架构质量审查-005-SDK-地图.md`

-   **多库共存**：
    -   多个 UI 库、工具库共存时是否有统一的调度机制
    -   是否评估它们之间的冲突与性能影响
    -   是否正确处理样式冲突

## 架构审查报告模板

待补充。

## 常见技术选型参考（References）

-   Vue 3 + UniApp：见 `references/选型-vue3+uniapp.md`
-   Vue 3 + Element Plus：见 `references/常用选型-vue3+elementplus.md`
-   Vue 2 + iView：见 `references/常用选型-vue2-iview.md`
-   Vue 2 + Vux + Webpack 3：见 `references/常用选型-vue2-vux-webpack3.md`
-   Android：见 `references/常用选型-android.md`
-   iOS：见 `references/常用选型-ios.md`
